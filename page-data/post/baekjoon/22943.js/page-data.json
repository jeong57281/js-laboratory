{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/22943.js","result":{"data":{"file":{"ext":".js","name":"22943","fields":{"content":"// prettier-ignore\n{var fs=require('fs');var filePath=process.platform==='linux'?'/dev/stdin':'./input';var stdin=fs.readFileSync(filePath).toString().trim().split('\\n').map(t=>t.trim());var input=(()=>{var t=0;return()=>stdin[t++]})();var SI=()=>input();var NI=()=>parseInt(input());var SAI=(t=' ')=>input().split(t);var NAI=(t=' ')=>input().split(t).map(Number);var CA=(t,r=null)=>Array(t).fill(r);var CAA=(t,r,i=null)=>Array.from(Array(t),()=>Array(r).fill(i));var CAAA=(t,r,i,e=null)=>Array.from(Array(t),()=>Array.from(Array(r),()=>Array(i).fill(e)));var P=console.log;var lowerBound=(t,r)=>{let i=0;let e=t.length;let s;while(i<e){s=Math.floor((i+e)/2);if(t[s]<r){i=s+1}else{e=s}}return e};class QueueNode{constructor(t){this.item=t;this.next=null}}class Queue{constructor(){this._size=0;this._front=null;this._rear=null}push(t){const r=new QueueNode(t);if(this.empty()){this._front=this._rear=r;this._size++;return}this._rear.next=r;this._rear=r;this._size++}pop(){if(this.empty()){return-1}if(this.size()===1){this._size--;const t=this._front.item;this._front=this._rear=null;return t}this._size--;const t=this._front.item;this._front=this._front.next;return t}size(){return this._size}empty(){return!this._size?1:0}front(){if(this.empty()){return-1}return this._front.item}back(){if(this.empty()){return-1}return this._rear.item}}class Heap{constructor(t=(t,r)=>t<r){this.heap=[null];this.compare=t}insert(t){this.heap.push(t);let r=this.heap.length-1;while(r!==1&&this.compare(t,this.heap[Math.floor(r/2)])){this.heap[r]=this.heap[Math.floor(r/2)];r=Math.floor(r/2)}this.heap[r]=t}delete(){const t=this.heap[1],r=this.heap.pop(),i=this.heap.length-1;let e=1,s=2;while(s<=i){if(s<i&&this.compare(this.heap[s+1],this.heap[s])){s+=1}if(this.compare(r,this.heap[s])){break}this.heap[e]=this.heap[s];e=s;s*=2}if(this.heap.length>1){this.heap[e]=r}return t}empty(){return this.heap.length===1}}class PriorityQueue{constructor(t){this.heap=new Heap(t)}empty(){return this.heap.empty()}peek(){return this.heap.heap[1]}push(t){this.heap.insert(t)}pop(){if(!this.empty())return this.heap.delete();else return null}}class DisjointSet{constructor(t){this.parent=Array(t).fill(null).map((t,r)=>r);this.rank=Array(t+1).fill(1)}find(t){if(this.parent[t]===t){return this.parent[t]}return this.parent[t]=this.find(this.parent[t])}merge(t,r){t=this.find(t);r=this.find(r);if(t===r){return}if(this.rank[t]>this.rank[r]){[t,r]=[r,t]}this.parent[t]=r;if(this.rank[t]===this.rank[r]){this.rank[r]++}}}}\n\nconst [K, M] = NAI();\n\nlet ans = 0;\n\nconst max = 1e5;\n\nlet isPrime = CA(max + 1, true);\n\nisPrime[0] = isPrime[1] = false;\n\nfor (let i = 2; i <= max; i++) {\n  if (isPrime[i]) {\n    for (let j = i + i; j <= max; j += i) {\n      isPrime[j] = false;\n    }\n  }\n}\n\nconst prime = isPrime\n  .map((v, i) => {\n    return v ? i : null;\n  })\n  .filter((v) => v);\n\nconst chk1 = (num) => {\n  let valid = false;\n\n  for (let p of prime) {\n    if (p === num - p) {\n      continue;\n    }\n\n    if (p > num) {\n      break;\n    }\n\n    if (isPrime[num - p]) {\n      valid = true;\n    }\n  }\n\n  return valid;\n};\n\nconst chk2 = (num) => {\n  let tmp = num;\n\n  while (tmp % M === 0) {\n    tmp = tmp / M;\n  }\n\n  let divisor = new Set();\n\n  divisor.add(1);\n\n  for (let i = 2; i * i <= tmp; i++) {\n    if (tmp % i === 0) {\n      divisor.add(i);\n      divisor.add(tmp / i);\n    }\n  }\n\n  divisor.add(tmp);\n\n  divisor = [...divisor];\n  divisor.sort((a, b) => a - b);\n\n  for (let i = 0; i < Math.ceil(divisor.length / 2); i++) {\n    if (isPrime[divisor[i]] && isPrime[divisor[divisor.length - 1 - i]]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst solve = (num, visited) => {\n  if (num.length === K) {\n    if (chk1(parseInt(num)) && chk2(parseInt(num))) {\n      ans++;\n    }\n\n    return;\n  }\n\n  for (let i = 0; i <= 9; i++) {\n    if (num.length === 0 && i === 0) {\n      continue;\n    }\n\n    if (visited[i]) {\n      continue;\n    }\n\n    visited[i] = true;\n    solve(num + `${i}`, visited);\n    visited[i] = false;\n  }\n};\n\nsolve('', CA(10));\n\nP(ans);\n","stampObject":{"modified":1679282113,"created":1678693761}}},"markdownRemark":{"html":"<h2>풀이 방법</h2>\n<ol>\n<li>0~9사이의 수 중 서로다른 K개를 골라 한번씩 사용하여 만들 수 있는 K자릿수의 수를 모두 구한다. (단, leading zero인 수는 제외한다.)</li>\n<li>만들 수 있는 모든 수에 대하여 1, 2번 조건을 만족하는지 확인한다.\n<ol>\n<li>1번 조건은 K가 최대 5이므로 넉넉히 10만까지의 모든 소수를 '에라토스테네스의 체'를 이용하여 구해둔 후, 모든 소수에 대하여 <code>현재 값 - 소수</code>가 소수인지를 확인하면 된다. (단, 서로 다른 두개의 소수라는 조건을 예외처리 해야한다.)</li>\n<li>2번 조건은 현재 값의 약수를 구하면 모든 두 수의 조합을 알 수 있다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><msqrt><mi mathvariant=\"normal\">N</mi></msqrt><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(\\sqrt N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1767em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9267em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathrm\" style=\"padding-left:0.833em;\">N</span></span><span style=\"top:-2.8867em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1133em;\"><span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> 알고리즘으로 모든 약수를 구하고 모든 조합에 대하여 두 수가 소수인 경우를 찾아 확인한다.</li>\n</ol>\n</li>\n</ol>\n<p>가능한 모든 수가 K가 5일 때 27,216개 뿐이고, 약수의 개수는 이보다 더 적으므로 시간안에 통과할 수 있다.</p>\n<h2>계속 틀렸습니다를 받은 이유</h2>\n<p>Set 자료구조는 입력 순서가 보장된다. 하지만 중복된 값이 들어올 경우에는 순서가 새롭게 갱신되지 않으므로 정렬이 필요하다.</p>","frontmatter":{"title":"22943번: 수"}}},"pageContext":{"slug":"baekjoon/22943.js","slugNoExt":"baekjoon/22943","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}