{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/12757.js","result":{"data":{"file":{"ext":".js","name":"12757","fields":{"content":"// prettier-ignore\n{const t=require('fs');const e=process.platform==='linux'?'/dev/stdin':'./input';const r=t.readFileSync(e).toString().trim().split('\\n').map(t=>t.trim());const i=(()=>{let t=0;return()=>r[t++]})();global.input=i;global.SI=()=>i();global.NI=()=>parseInt(i());global.SAI=(t=' ')=>i().split(t);global.NAI=(t=' ')=>i().split(t).map(Number);global.CA=(t,e=null)=>Array(t).fill(e);global.CAA=(t,e,r=null)=>Array.from(Array(t),()=>Array(e).fill(r));global.CAAA=(t,e,r,i=null)=>Array.from(Array(t),()=>Array.from(Array(e),()=>Array(r).fill(i)));global.P=console.log;const s=(t,e)=>{let r=0;let i=t.length;let s;while(r<i){s=Math.floor((r+i)/2);if(t[s]<e){r=s+1}else{i=s}}return i};global.lowerBound=s;class h{constructor(t){this.key=t;this.next=null}}class l{constructor(){this._size=0;this._front=null;this._rear=null}push(t){const e=new h(t);if(this.empty()){this._front=this._rear=e;this._size++;return}this._rear.next=e;this._rear=e;this._size++}pop(){if(this.empty()){return-1}if(this.size()===1){this._size--;const t=this._front.key;this._front=this._rear=null;return t}this._size--;const t=this._front.key;this._front=this._front.next;return t}size(){return this._size}empty(){return!this._size?1:0}front(){if(this.empty()){return-1}return this._front.key}back(){if(this.empty()){return-1}return this._rear.key}}global.QueueNode=h;global.Queue=l;class n{constructor(t=(t,e)=>t<e){this.heap=[null];this.compare=t}insert(t){this.heap.push(t);let e=this.heap.length-1;while(e!==1&&this.compare(t,this.heap[Math.floor(e/2)])){this.heap[e]=this.heap[Math.floor(e/2)];e=Math.floor(e/2)}this.heap[e]=t}delete(){const t=this.heap[1],e=this.heap.pop(),r=this.heap.length-1;let i=1,s=2;while(s<=r){if(s<r&&this.compare(this.heap[s+1],this.heap[s])){s+=1}if(this.compare(e,this.heap[s])){break}this.heap[i]=this.heap[s];i=s;s*=2}if(this.heap.length>1){this.heap[i]=e}return t}empty(){return this.heap.length===1}}class a{constructor(t){this.heap=new n(t)}empty(){return this.heap.empty()}peek(){return this.heap.heap[1]}push(t){this.heap.insert(t)}pop(){if(!this.empty())return this.heap.delete();else return null}}global.Heap=n;global.PriorityQueue=a;class o{constructor(t){this.parent=Array(t).fill(null).map((t,e)=>e);this.rank=Array(t+1).fill(1)}find(t){if(this.parent[t]===t){return this.parent[t]}return this.parent[t]=this.find(this.parent[t])}merge(t,e){t=this.find(t);e=this.find(e);if(t===e){return}if(this.rank[t]>this.rank[e]){[t,e]=[e,t]}this.parent[t]=e;if(this.rank[t]===this.rank[e]){this.rank[e]++}}}global.DisjointSet=o}\n\n// avl 트리 공부한 후 편향 트리가 되지 않게 개선이 필요함.\n\nclass BSTNode {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.llink = null;\n    this.rlink = null;\n    this.height = 1;\n  }\n}\n\nclass BST {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(key, value) {\n    let tmp = this.root;\n\n    let parent = null;\n\n    while (tmp !== null) {\n      if (key === tmp.key) {\n        return;\n      }\n\n      parent = tmp;\n\n      if (key < tmp.key) {\n        tmp = tmp.llink;\n      } else {\n        tmp = tmp.rlink;\n      }\n    }\n\n    const newNode = new BSTNode(key, value);\n\n    if (this.root === null) {\n      this.root = newNode;\n    } else {\n      if (key < parent.key) {\n        parent.llink = newNode;\n      } else {\n        parent.rlink = newNode;\n      }\n    }\n  }\n\n  search(key, node = this.root, tmp = []) {\n    if (node === null) {\n      return tmp;\n    }\n\n    tmp.push(node);\n\n    if (key < node.key) {\n      this.search(key, node.llink, tmp);\n    } else {\n      this.search(key, node.rlink, tmp);\n    }\n\n    return tmp;\n  }\n}\n\nconst bst = new BST();\n\nconst [N, M, K] = NAI();\n\nfor (let i = 0; i < N; i++) {\n  const [k, v] = NAI();\n\n  bst.insert(k, v);\n}\n\nfor (let i = 0; i < M; i++) {\n  const [type, key, value] = NAI();\n\n  let nodes;\n\n  switch (type) {\n    case 1:\n      bst.insert(key, value);\n      break;\n    case 2:\n      nodes = bst.search(key).filter((node) => Math.abs(node.key - key) <= K);\n\n      nodes.sort((a, b) => Math.abs(a.key - key) - Math.abs(b.key - key));\n\n      if (!nodes.length) {\n        break;\n      }\n\n      nodes[0].value = value;\n      break;\n    case 3:\n      nodes = bst\n        .search(key)\n        .map((node) => ({\n          key: node.key,\n          value: node.value,\n          diff: Math.abs(node.key - key),\n        }))\n        .filter((v) => v.diff <= K);\n\n      if (!nodes.length) {\n        P(-1);\n        break;\n      }\n\n      nodes.sort((a, b) => a.diff - b.diff);\n\n      if (nodes.length >= 2 && nodes[0].diff === nodes[1].diff) {\n        P('?');\n      } else {\n        P(nodes[0].value);\n      }\n\n      break;\n  }\n}\n","stampObject":{"modified":1677766650,"created":1677766648}}},"markdownRemark":null},"pageContext":{"slug":"baekjoon/12757.js","slugNoExt":"baekjoon/12757","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}