{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/2616.js","result":{"data":{"file":{"ext":".js","name":"2616","fields":{"content":"// baekjoon input template\n// prettier-ignore\n{var fs=require('fs');var filePath=process.platform==='linux'?'/dev/stdin':'./input';var stdin=fs.readFileSync(filePath).toString().trim().split('\\n').map(s=>s.trim());var input=(()=>{var line=0;return()=>stdin[line++]})();var SI=()=>input();var NI=()=>parseInt(input());var SAI=(sep=' ')=>input().split(sep);var NAI=(sep=' ')=>input().split(sep).map(Number);var CA=(n,v=null)=>Array(n).fill(v);var CAA=(n,m,v=null)=>Array.from(Array(n),()=>Array(m).fill(v));var CAAA=(n,m,h,v=null)=>Array.from(Array(n),()=>Array.from(Array(m),()=>Array(h).fill(v)));var P=console.log;}\n\nconst N = NI();\n\nconst T = NAI();\n\nT.unshift(0);\n\nfor (let i = 1; i < N + 1; i++) {\n  T[i] += T[i - 1];\n}\n\nconst C = NI();\n\nconst dp = CAA(3, N + 1, -1);\n\nconst solve = (num, idx) => {\n  if (idx + C - 1 > N) {\n    return 0;\n  }\n\n  if (num === 3) {\n    return 0;\n  }\n\n  if (dp[num][idx] !== -1) {\n    return dp[num][idx];\n  }\n\n  let ret = 0;\n\n  ret = Math.max(\n    solve(num, idx + 1),\n    solve(num + 1, idx + C) + (T[idx + C - 1] - T[idx - 1])\n  );\n\n  return (dp[num][idx] = ret);\n};\n\nP(solve(0, 1));\n","stampObject":{"modified":1679887794,"created":1679651816}}},"markdownRemark":{"html":"<p>모든 경우를 구해 메모이제이션하면 풀리지 않을까? 생각하고 제한조건을 보니 N이 5만으로 재귀 함수에서 복잡도가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"normal\">N</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(N^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> 으로, 불가능해보여 다른 방법을 찾다 결국 해결하지 못하고 답을 보았던 문제이다.</p>\n<p>답을 보았더니 처음 생각했던 접근이 맞았다. 시간초과가 날 것 같은데 내가 복잡도 계산을 잘못했나 싶어, dp + memoization 을 이용하여 풀이하였는데 역시 시간초과가 났다.</p>\n<p>이유를 찾아보니 한 가지 차이점이 있었다. 핵심은 재귀에서 최대 5만번의 반복문을 돌려주는 것이 아닌, 소형 기관차가 현재 객차를 선택하느냐, 선택하지 않느냐 두 가지의 경우로 나누어 재귀 호출해주는 것이었다.</p>\n<p>N값이 매우 클 경우 수평적으로 매우 많은 재귀 호출이 발생하면서 메모이제이션이 되기 전에 시간초과가 발생하게 되는 것이었다.</p>\n<p>+ 누적합이 분류에 있는 이유는, 누적합을 이용하지 않고 일일이 구간값을 계산한다면 복잡도가 매우 커지기 때문이다. 기존 복잡도에 최대 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mn>50</mn><mo separator=\"true\">,</mo><mn>000</mn></mrow><mn>3</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">50,000 \\over 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2422em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8972em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">50</span><span class=\"mpunct mtight\">,</span><span class=\"mord mtight\">000</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span> 값을 곱한다고 생각하면 된다.</p>","frontmatter":{"title":"2616번: 소형기관차"}}},"pageContext":{"slug":"baekjoon/2616.js","slugNoExt":"baekjoon/2616","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}