{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/20366.js","result":{"data":{"file":{"ext":".js","name":"20366","fields":{"content":"// prettier-ignore\n{const t=require('fs');const e=process.platform==='linux'?'/dev/stdin':'./input';const i=t.readFileSync(e).toString().trim().split('\\n').map(t=>t.trim());const s=(()=>{let t=0;return()=>i[t++]})();global.S=()=>s();global.I=()=>parseInt(s());global.AS=(t=' ')=>s().split(t);global.AI=(t=' ')=>s().split(t).map(Number);global.P=console.log;const r=(t,e)=>{let i=0;let s=t.length;let r;while(i<s){r=Math.floor((i+s)/2);if(t[r]<e){i=r+1}else{s=r}}return s};global.lowerBound=r;class h{constructor(t){this.item=t;this.next=null}}class n{constructor(){this._size=0;this._front=null;this._rear=null}push(t){const e=new h(t);if(this.empty()){this._front=this._rear=e;this._size++;return}this._rear.next=e;this._rear=e;this._size++}pop(){if(this.empty()){return-1}if(this.size()===1){this._size--;const t=this._front.item;this._front=this._rear=null;return t}this._size--;const t=this._front.item;this._front=this._front.next;return t}size(){return this._size}empty(){return!this._size?1:0}front(){if(this.empty()){return-1}return this._front.item}back(){if(this.empty()){return-1}return this._rear.item}}global.QueueNode=h;global.Queue=n;class a{constructor(t=(t,e)=>t<e){this.heap=[null];this.compare=t}insert(t){this.heap.push(t);let e=this.heap.length-1;while(e!==1&&this.compare(t,this.heap[Math.floor(e/2)])){this.heap[e]=this.heap[Math.floor(e/2)];e=Math.floor(e/2)}this.heap[e]=t}delete(){const t=this.heap[1],e=this.heap.pop(),i=this.heap.length-1;let s=1,r=2;while(r<=i){if(r<i&&this.compare(this.heap[r+1],this.heap[r])){r+=1}if(this.compare(e,this.heap[r])){break}this.heap[s]=this.heap[r];s=r;r*=2}if(this.heap.length>1){this.heap[s]=e}return t}empty(){return this.heap.length===1}}class l{constructor(t){this.heap=new a(t)}empty(){return this.heap.empty()}peek(){return this.heap.heap[1]}push(t){this.heap.insert(t)}pop(){if(!this.empty())return this.heap.delete();else return null}}global.Heap=a;global.PriorityQueue=l;class o{constructor(t){this.parent=Array(t).fill(null).map((t,e)=>e);this.rank=Array(t+1).fill(1)}find(t){if(this.parent[t]===t){return this.parent[t]}return this.parent[t]=this.find(this.parent[t])}merge(t,e){t=this.find(t);e=this.find(e);if(t===e){return}if(this.rank[t]>this.rank[e]){[t,e]=[e,t]}this.parent[t]=e;if(this.rank[t]===this.rank[e]){this.rank[e]++}}}global.DisjointSet=o}\n\nconst N = I();\n\nconst H = AI();\n\nH.sort((a, b) => a - b);\n\nconst twoPointer = (target, L, R) => {\n  let l = L,\n    r = R - 1;\n  let ret = Infinity;\n\n  while (l < r) {\n    const m = H[l] + H[r];\n\n    ret = Math.min(ret, Math.abs(target - m));\n\n    if (m > target) {\n      r--;\n    } else if (m < target) {\n      l++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n};\n\nlet ans = Infinity;\n\nfor (let i = 0; i < N; i++) {\n  for (let j = i + 3; j < N; j++) {\n    ans = Math.min(ans, twoPointer(H[i] + H[j], i + 1, j));\n  }\n}\n\nP(ans);\n","stampObject":{"modified":1677143301,"created":1677142080}}},"markdownRemark":{"html":"<p><a href=\"https://www.acmicpc.net/problem/14921\">14921번: 용액 합성하기</a>와 거의 동일한 투 포인터 문제이다.</p>\n<h2>풀이 방법</h2>\n<ol>\n<li>눈덩이 지름을 오름차순으로 정렬한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">N</mi><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi mathvariant=\"normal\">N</mi><mo stretchy=\"false\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">O(\\rm N \\cdot \\log N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">N</span><span class=\"mclose\">)</span></span></span></span></span></span></li>\n<li>눈덩이들 중 2개를 골라 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow></mrow><mi mathvariant=\"normal\">N</mi></msub><msub><mi mathvariant=\"normal\">C</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\rm _N C _2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></span> 눈사람 하나를 만들고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mrow><msup><mi mathvariant=\"normal\">N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">O(\\rm N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span></li>\n<li>고른 눈덩이 2개를 제외한 눈덩이 배열을 만든 후, 투 포인터 알고리즘으로 다른 눈사람과의 차이가 최소가 되도록 하는 두 눈덩이를 고른다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">N</mi><mo stretchy=\"false\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">O(\\rm N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"mclose\">)</span></span></span></span></span></span></li>\n</ol>\n<h3>시간 복잡도</h3>\n<p>2, 3번 과정에서 전체 복잡도가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mrow><msup><mi mathvariant=\"normal\">N</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">O(\\rm N^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> 으로 지배되고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\rm N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">N</span></span></span></span></span></span>이 최대 600이므로 시간 복잡도는 만족한다.</p>\n<h3>공간 복잡도</h3>\n<p>3번에서 <strong>크기가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\rm N-2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathrm\">2</span></span></span></span></span></span>인 새로운 배열을 만들어</strong> 배열의 모든 범위에서 투 포인터 알고리즘을 실행하고 있는데, 문제의 메모리 제한이 1GB로 넉넉한 탓에 느리게 통과는 되지만 이를 더 최적화 할 수 있다.</p>\n<ul>\n<li>최적화 방법</li>\n</ul>\n<p>처음 두 눈덩이를 선택할 때 눈덩이 사이에 최소 2개의 눈덩이가 있도록 고르고, 사이에 있는 눈덩이들에 대해서만 투 포인터 알고리즘으로 키의 차이가 최소가 되는 다른 눈덩이 두개를 찾는 것이다.</p>\n<p>지름을 기준으로 오름차순으로 눈덩이가 정렬되어 있는 상태이기 때문에 고른 두 둔덩이의 좌우 값은 ~ 가능하다.</p>\n<br/>\n<p>정렬 두번으로도 풀이가 가능, 눈사람 A의 크기를 기준으로 또 한번 정렬하고, 인접한 항목의 인덱스를 비교해서 걸러내면 그안에 정답이 존재한다? 신기.</p>","frontmatter":{"title":"20366번: 같이 눈사람 만들래?"}}},"pageContext":{"slug":"baekjoon/20366.js","slugNoExt":"baekjoon/20366","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}