{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/16472.js","result":{"data":{"file":{"ext":".js","name":"16472","fields":{"content":"// prettier-ignore\n{var fs=require('fs');var filePath=process.platform==='linux'?'/dev/stdin':'./input';var stdin=fs.readFileSync(filePath).toString().trim().split('\\n').map(t=>t.trim());var input=(()=>{var t=0;return()=>stdin[t++]})();var SI=()=>input();var NI=()=>parseInt(input());var SAI=(t=' ')=>input().split(t);var NAI=(t=' ')=>input().split(t).map(Number);var CA=(t,r=null)=>Array(t).fill(r);var CAA=(t,r,i=null)=>Array.from(Array(t),()=>Array(r).fill(i));var CAAA=(t,r,i,e=null)=>Array.from(Array(t),()=>Array.from(Array(r),()=>Array(i).fill(e)));var P=console.log;var lowerBound=(t,r)=>{let i=0;let e=t.length;let s;while(i<e){s=Math.floor((i+e)/2);if(t[s]<r){i=s+1}else{e=s}}return e};class QueueNode{constructor(t){this.item=t;this.next=null}}class Queue{constructor(){this._size=0;this._front=null;this._rear=null}push(t){const r=new QueueNode(t);if(this.empty()){this._front=this._rear=r;this._size++;return}this._rear.next=r;this._rear=r;this._size++}pop(){if(this.empty()){return-1}if(this.size()===1){this._size--;const t=this._front.item;this._front=this._rear=null;return t}this._size--;const t=this._front.item;this._front=this._front.next;return t}size(){return this._size}empty(){return!this._size?1:0}front(){if(this.empty()){return-1}return this._front.item}back(){if(this.empty()){return-1}return this._rear.item}}class Heap{constructor(t=(t,r)=>t<r){this.heap=[null];this.compare=t}insert(t){this.heap.push(t);let r=this.heap.length-1;while(r!==1&&this.compare(t,this.heap[Math.floor(r/2)])){this.heap[r]=this.heap[Math.floor(r/2)];r=Math.floor(r/2)}this.heap[r]=t}delete(){const t=this.heap[1],r=this.heap.pop(),i=this.heap.length-1;let e=1,s=2;while(s<=i){if(s<i&&this.compare(this.heap[s+1],this.heap[s])){s+=1}if(this.compare(r,this.heap[s])){break}this.heap[e]=this.heap[s];e=s;s*=2}if(this.heap.length>1){this.heap[e]=r}return t}empty(){return this.heap.length===1}}class PriorityQueue{constructor(t){this.heap=new Heap(t)}empty(){return this.heap.empty()}peek(){return this.heap.heap[1]}push(t){this.heap.insert(t)}pop(){if(!this.empty())return this.heap.delete();else return null}}class DisjointSet{constructor(t){this.parent=Array(t).fill(null).map((t,r)=>r);this.rank=Array(t+1).fill(1)}find(t){if(this.parent[t]===t){return this.parent[t]}return this.parent[t]=this.find(this.parent[t])}merge(t,r){t=this.find(t);r=this.find(r);if(t===r){return}if(this.rank[t]>this.rank[r]){[t,r]=[r,t]}this.parent[t]=r;if(this.rank[t]===this.rank[r]){this.rank[r]++}}}}\n\nconst N = NI();\n\nconst s = SI();\n\nconst cnt = CA(26, 0);\n\nlet l = 0,\n  r = 0;\n\ncnt[s[0].charCodeAt(0) - 0x61]++;\n\nlet ans = 0;\n\nwhile (l < s.length && r < s.length) {\n  const tmp = cnt.filter((v) => v);\n\n  if (tmp.length <= N) {\n    ans = Math.max(ans, s.slice(l, r + 1).length);\n\n    r++;\n\n    if (r >= s.length) {\n      break;\n    }\n\n    cnt[s[r].charCodeAt(0) - 0x61]++;\n  } else {\n    cnt[s[l].charCodeAt(0) - 0x61]--;\n    l++;\n  }\n}\n\nP(ans);\n","stampObject":{"modified":1678693761,"created":1678693761}}},"markdownRemark":{"html":"<p>종류가 N개 이하인 연속된 문자열들을 전부 찾아주면 된다.</p>\n<p>'연속'된 문자열이라는 조건이 있으므로, 범위를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[0, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> 부터 시작하여 현재 문자열의 종류가 N개보다 작거나 같으면 다음 문자를 추가해보고, N보다 크다면 이전 문자열을 제거해 범위를 줄여나가는 식으로 문자열의 끝까지 조사하는 투 포인터 알고리즘을 이용하면 해결할 수 있다.</p>\n<p>알파벳 소문자의 개수가 26개이므로, 복잡도는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><mn>26</mn><mo>⋅</mo><mi mathvariant=\"normal\">N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(26 \\cdot N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">26</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathrm\">N</span><span class=\"mclose\">)</span></span></span></span></span></span> 가 된다.</p>","frontmatter":{"title":"16472번: 고냥이"}}},"pageContext":{"slug":"baekjoon/16472.js","slugNoExt":"baekjoon/16472","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}