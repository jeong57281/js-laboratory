{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/1644.js","result":{"data":{"file":{"ext":".js","name":"1644","fields":{"content":"// prettier-ignore\n{const t=require('fs');const e=process.platform==='linux'?'/dev/stdin':'./input';const r=t.readFileSync(e).toString().trim().split('\\n').map(t=>t.trim());const i=(()=>{let t=0;return()=>r[t++]})();global.input=i;global.SI=()=>i();global.NI=()=>parseInt(i());global.SAI=(t=' ')=>i().split(t);global.NAI=(t=' ')=>i().split(t).map(Number);global.CA=(t,e=null)=>Array(t).fill(e);global.CAA=(t,e,r=null)=>Array.from(Array(t),()=>Array(e).fill(r));global.CAAA=(t,e,r,i=null)=>Array.from(Array(t),()=>Array.from(Array(e),()=>Array(r).fill(i)));global.P=console.log;const s=(t,e)=>{let r=0;let i=t.length;let s;while(r<i){s=Math.floor((r+i)/2);if(t[s]<e){r=s+1}else{i=s}}return i};global.lowerBound=s;class h{constructor(t){this.item=t;this.next=null}}class l{constructor(){this._size=0;this._front=null;this._rear=null}push(t){const e=new h(t);if(this.empty()){this._front=this._rear=e;this._size++;return}this._rear.next=e;this._rear=e;this._size++}pop(){if(this.empty()){return-1}if(this.size()===1){this._size--;const t=this._front.item;this._front=this._rear=null;return t}this._size--;const t=this._front.item;this._front=this._front.next;return t}size(){return this._size}empty(){return!this._size?1:0}front(){if(this.empty()){return-1}return this._front.item}back(){if(this.empty()){return-1}return this._rear.item}}global.QueueNode=h;global.Queue=l;class n{constructor(t=(t,e)=>t<e){this.heap=[null];this.compare=t}insert(t){this.heap.push(t);let e=this.heap.length-1;while(e!==1&&this.compare(t,this.heap[Math.floor(e/2)])){this.heap[e]=this.heap[Math.floor(e/2)];e=Math.floor(e/2)}this.heap[e]=t}delete(){const t=this.heap[1],e=this.heap.pop(),r=this.heap.length-1;let i=1,s=2;while(s<=r){if(s<r&&this.compare(this.heap[s+1],this.heap[s])){s+=1}if(this.compare(e,this.heap[s])){break}this.heap[i]=this.heap[s];i=s;s*=2}if(this.heap.length>1){this.heap[i]=e}return t}empty(){return this.heap.length===1}}class a{constructor(t){this.heap=new n(t)}empty(){return this.heap.empty()}peek(){return this.heap.heap[1]}push(t){this.heap.insert(t)}pop(){if(!this.empty())return this.heap.delete();else return null}}global.Heap=n;global.PriorityQueue=a;class o{constructor(t){this.parent=Array(t).fill(null).map((t,e)=>e);this.rank=Array(t+1).fill(1)}find(t){if(this.parent[t]===t){return this.parent[t]}return this.parent[t]=this.find(this.parent[t])}merge(t,e){t=this.find(t);e=this.find(e);if(t===e){return}if(this.rank[t]>this.rank[e]){[t,e]=[e,t]}this.parent[t]=e;if(this.rank[t]===this.rank[e]){this.rank[e]++}}}global.DisjointSet=o}\n\nconst max = 4e6;\n\nlet isPrime = CA(max + 1, true);\n\nisPrime[0] = isPrime[1] = false;\n\nfor (let i = 2; i <= max; i++) {\n  if (isPrime[i]) {\n    for (let j = i + i; j <= max; j += i) {\n      isPrime[j] = false;\n    }\n  }\n}\n\nconst prime = isPrime\n  .map((v, i) => {\n    return v ? i : null;\n  })\n  .filter((v) => v);\n\nlet l = 0;\nlet r = 1;\n\nlet cnt = 0;\n\nlet target = NI();\n\nlet sum = prime[l] + prime[r];\n\nwhile (l < r && l < prime.length && r < prime.length) {\n  if (sum < target) {\n    r++;\n    sum += prime[r];\n  } else {\n    if (sum === target) {\n      cnt++;\n    }\n\n    sum -= prime[l];\n    l++;\n  }\n}\n\nP(isPrime[target] ? cnt + 1 : cnt);\n","stampObject":{"modified":1678295619,"created":1677516579}}},"markdownRemark":{"html":"<h2>풀이 방법</h2>\n<ol>\n<li>에라토스테네스의 체로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">N</span><span class=\"mclose\">)</span></span></span></span></span></span> 시간안에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo separator=\"true\">,</mo><mn>000</mn><mo separator=\"true\">,</mo><mn>000</mn></mrow><annotation encoding=\"application/x-tex\">\\rm 4,000,000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">000</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">000</span></span></span></span></span></span> 이하의 소수들을 구한다. (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><msqrt><mi mathvariant=\"normal\">N</mi></msqrt><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(\\sqrt{N}) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1767em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9267em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathrm\">N</span></span></span><span style=\"top:-2.8867em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1133em;\"><span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> 혹은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"normal\">N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> 으로 소수들을 구할경우 시간초과가 난다.)</li>\n<li><strong>연속합</strong>이라는 문제 규칙과 <strong>오름차순으로 정렬된 소수 배열</strong>을 이용하여 제일 작은 소수 2개(2와 3)부터 시작해서, 다음 소수를 추가하거나 제일 작은 소수를 제외하며 찾으려는 값과 동일할 때 경우의 수를 세어주면 된다.</li>\n</ol>","frontmatter":{"title":"1644번: 소수의 연속합"}}},"pageContext":{"slug":"baekjoon/1644.js","slugNoExt":"baekjoon/1644","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}