{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/11437.js","result":{"data":{"file":{"ext":".js","name":"11437","fields":{"content":"const fs = require(\"fs\");\nconst filePath = process.platform === \"linux\" ? \"/dev/stdin\" : \"./input\";\nconst stdin = fs\n  .readFileSync(filePath)\n  .toString()\n  .trim()\n  .split(\"\\n\")\n  .map((s) => s.trim());\nconst input = (() => {\n  let line = 0;\n  return () => stdin[line++];\n})();\n\nconst N = parseInt(input());\n\nconst adj = Array.from(Array(N + 1), () => []);\n\nfor (let i = 0; i < N - 1; i++) {\n  const [u, v] = input().split(\" \").map(Number);\n\n  adj[u].push(v);\n  adj[v].push(u);\n}\n\nconst parent = Array(N + 1);\n\nconst dfs = (prev, cur, depth, adj, visited, parent) => {\n  // 기저 사례\n  if (visited[cur]) {\n    return;\n  }\n\n  visited[cur] = true;\n\n  // 재귀 호출\n  parent[cur] = prev;\n\n  for (let i = 0; i < adj[cur].length; i++) {\n    const next = adj[cur][i];\n\n    dfs(cur, next, depth + 1, adj, visited, parent);\n  }\n};\n\ndfs(1, 1, 1, adj, Array(N + 1).fill(false), parent);\n\nconst setParentList = (parent, arr, cur) => {\n  arr[0] = cur;\n\n  let i, tmp;\n\n  for (i = 1, tmp = cur; tmp !== 1; i++) {\n    arr[i] = parent[tmp];\n\n    tmp = parent[tmp];\n  }\n\n  return i;\n};\n\nconst M = parseInt(input());\n\nlet ans = [];\n\nconst ap = Array(N);\nconst bp = Array(N);\n\nfor (let i = 0; i < M; i++) {\n  const [a, b] = input().split(\" \").map(Number);\n\n  let as = setParentList(parent, ap, a);\n  let bs = setParentList(parent, bp, b);\n\n  let tmp;\n\n  while (as-- && bs--) {\n    const ar = ap[as];\n    const br = bp[bs];\n\n    if (ar !== br) {\n      break;\n    }\n\n    tmp = ar;\n  }\n\n  ans.push(tmp);\n}\n\nconsole.log(ans.join(\"\\n\"));\n","stampObject":{"modified":1676957883,"created":1676957883}}},"markdownRemark":{"html":"<p>Lowest Common Ancestor 최소 공통 조상을 찾는 문제이다.</p>\n<p>문제 조건을 보면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>과 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span>이 각각 최대 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>50</mn><mo separator=\"true\">,</mo><mn>000</mn></mrow><annotation encoding=\"application/x-tex\">50,000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">50</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">000</span></span></span></span></span>과 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10</mn><mo separator=\"true\">,</mo><mn>000</mn></mrow><annotation encoding=\"application/x-tex\">10,000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">10</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">000</span></span></span></span></span>이다.</p>\n<p>제일 쉽게 생각해 낸 풀이 방법은 다음과 같다.</p>\n<ol>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span>개의 쌍에 대해서</li>\n<li>두 정점의 모든 조상을 찾고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>⋅</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">2 \\cdot N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></li>\n<li>두 정점의 공통된 조상을 찾는다 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></li>\n</ol>\n<p>위의 방법은 복잡도가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>3</mn><mi>N</mi><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(3NM)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">NM</span><span class=\"mclose\">)</span></span></span></span></span>으로 15억이면 통과하기 힘들겠다 생각하고 다른 방법을 찾고 있었는데 도무지 생각이 나질 않았다.</p>\n<p>포기하고 정답을 보려다가 다른 문제에 비해 제한시간이 3초로 긴 것을 뒤늦게 발견했다. 어쩌면 별다른 알고리즘 없이 단순무식한 위의 방법으로도 풀리게끔 낸 문제일지 모른다는 생각이 들었고, 그대로 구현하여 제출했더니 AC를 받았다.</p>\n<p>+ AC를 받기 전에 메모리 초과가 한번 발생했었다. 이유는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span>개에 쌍에 대해서 조상을 찾을 때 마다 새로운 배열을 생성하여 계산해줬는데, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>×</mo><mi>M</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">2 \\times M \\times N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span> 로 최대 10억의 메모리 공간을 차지했기 때문이었다.</p>\n<p><a href=\"https://www.acmicpc.net/problem/11438\">11438번: LCA 2</a> 문제는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>안으로 LCA를 구하는 방법을 알아야 풀 수 있을 것 같다.</p>","frontmatter":{"title":"11437번: LCA"}}},"pageContext":{"slug":"baekjoon/11437.js","slugNoExt":"baekjoon/11437","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}