{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/6173.js","result":{"data":{"file":{"ext":".js","name":"6173","fields":{"content":"console.log(ans.join(\"\\n\"));\nconst fs = require(\"fs\");\nconst filePath = process.platform === \"linux\" ? \"/dev/stdin\" : \"./input\";\nconst stdin = fs\n  .readFileSync(filePath)\n  .toString()\n  .trim()\n  .split(\"\\n\")\n  .map((s) => s.trim());\nconst input = (() => {\n  let line = 0;\n  return () => stdin[line++];\n})();\n\nconst N = parseInt(input());\n\nconst S = [];\n\nconst T = [];\n\nfor (let i = 0; i < N; i++) {\n  S.push(input());\n}\n\nconst DIRECTION = {\n  LEFT: 0,\n  RIGHT: 1,\n};\n\nconst leftOrRight = (s, e, S) => {\n  let l = s;\n  let r = e;\n\n  while (l < r) {\n    if (S[l] < S[r]) {\n      return DIRECTION.LEFT;\n    } else if (S[l] > S[r]) {\n      return DIRECTION.RIGHT;\n    } else {\n      l++;\n      r--;\n    }\n  }\n\n  return DIRECTION.LEFT;\n};\n\nconst solve = (S, T) => {\n  let l = 0;\n  let r = N - 1;\n\n  while (l <= r) {\n    const direction = leftOrRight(l, r, S);\n\n    if (direction === DIRECTION.LEFT) {\n      T.push(S[l]);\n      l++;\n    } else {\n      T.push(S[r]);\n      r--;\n    }\n  }\n};\n\nsolve(S, T);\n\nlet ans = [];\n\nfor (let i = 0; i < Math.ceil(T.length / 80) * 80; i += 80) {\n  ans.push(T.slice(i, i + 80).join(\"\"));\n}\n\nconsole.log(ans.join(\"\\n\"));\n","stampObject":{"modified":1676552142,"created":1676552142}}},"markdownRemark":{"html":"<h3>2시간 넘게 시간이 걸린 이유</h3>\n<ol>\n<li>문자열 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span>의 앞이나 뒤에서 문자 <strong>하나</strong>를 떼어 문자열 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>에 추가할 때 마다, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span>의 앞, 뒤 문자의 우선순위가 달라지는 것을 고려하지 못했다.</li>\n</ol>\n<deckgo-highlight-code language=\"text\" theme=\"one-light\"  >\n          <code slot=\"code\">6\nA\nB\nC\nC\nB\nA\n\nanswer: AABBCC\noutput: ABCABC</code>\n        </deckgo-highlight-code>\n<p><strong>내가 작성한 알고리즘</strong></p>\n<ul>\n<li>양 끝 문자의 사전 순서가 같을 경우, 값 하나를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>에 추가해주고 양 끝을 1씩 좁힌다.</li>\n<li>양 끝 문자의 사전 순서가 다를 경우, 사전 순서가 빠른 값을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>에 추가하고 사전 순서가 빠른 값의 인덱스만 갱신한다.</li>\n</ul>\n<p><strong>수정한 알고리즘</strong></p>\n<p>매번 사전 순서가 다른 값이 나올 때 까지 탐색하여 왼쪽 혹은 오른쪽 값 <strong>하나</strong>를 제거할 지 판단하면 된다. (사전 순서가 다른 값이 나오지 않을 경우는 둘 중 어느 값을 지워도 상관없다고 판단한다.)</p>\n<ol start=\"2\">\n<li>중간에 걸려온 전화</li>\n</ol>\n<h3>틀린 이유인 줄 알았지만, 아니었던 것</h3>\n<ol>\n<li>80자 단위로 줄바꿈을 하여 출력할 때, 실수로 줄바꿈 문자를 몇개 더 추가하였지만 문제가 발생하지 않았다.</li>\n</ol>","frontmatter":{"title":"6173번: 문자열 생성"}}},"pageContext":{"slug":"baekjoon/6173.js","slugNoExt":"baekjoon/6173","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}