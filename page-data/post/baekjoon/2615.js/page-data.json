{"componentChunkName":"component---src-templates-post-tsx","path":"/post/baekjoon/2615.js","result":{"data":{"file":{"ext":".js","name":"2615","fields":{"content":"const fs = require(\"fs\");\nconst filePath = process.platform === \"linux\" ? \"/dev/stdin\" : \"./input\";\nconst stdin = fs\n  .readFileSync(filePath)\n  .toString()\n  .trim()\n  .split(\"\\n\")\n  .map((s) => s.trim());\nconst input = (() => {\n  let line = 0;\n  return () => stdin[line++];\n})();\n\nconst board = [];\n\nfor (let i = 0; i < 19; i++) {\n  board.push(input().split(\" \").map(Number));\n}\n\n// 0: right, 1: down, 2: left & down 3: right & down\nconst visited = Array.from(Array(4), () =>\n  Array.from(Array(19), () => Array(19).fill(false))\n);\n\nconst dy = [0, 1, 1, 1]; // → ↓ ↙ ↘\nconst dx = [1, 0, -1, 1];\n\nconst isFive = (arr) => {\n  if (arr.length !== 5) {\n    return false;\n  }\n\n  if (!arr.every((value) => value === arr[0])) {\n    return false;\n  }\n\n  return true;\n};\n\nconst chk = (d, y, x) => {\n  visited[d][y][x] = true;\n\n  let ny = y,\n    nx = x,\n    arr = [];\n\n  arr.push(board[y][x]);\n\n  while (true) {\n    ny += dy[d];\n    nx += dx[d];\n\n    if (nx < 0 || nx >= 19 || ny < 0 || ny >= 19) {\n      break;\n    }\n\n    if (board[ny][nx] !== board[y][x]) {\n      break;\n    }\n\n    visited[d][ny][nx] = true;\n    arr.push(board[ny][nx]);\n  }\n\n  return isFive(arr);\n};\n\nlet ans = \"\";\n\nouter: for (let y = 0; y < 19; y++) {\n  for (let x = 0; x < 19; x++) {\n    for (let d = 0; d < 4; d++) {\n      if (!board[y][x]) {\n        continue;\n      }\n\n      if (visited[d][y][x]) {\n        continue;\n      }\n\n      if (!chk(d, y, x)) {\n        continue;\n      }\n\n      ans += `${board[y][x]}\\n`;\n      ans += d === 2 ? `${y + 4 + 1} ${x - 4 + 1}` : `${y + 1} ${x + 1}`;\n      break outer;\n    }\n  }\n}\n\nconsole.log(ans ? ans : 0);\n","stampObject":{"modified":1676262885,"created":1676262885}}},"markdownRemark":{"html":"<h3>풀이 방법</h3>\n<p>검은 돌 '1', 흰 돌 '2' 일 경우 특정 방향으로 같은 돌이 아닐 때 까지 배열에 추가하고 오목인지를 판단했다.</p>\n<p>6목을 구분하기 위해서 배열에 추가되었던 원소는 방문 처리를 해 주었다.</p>\n<p>단, 방문 배열을 공유할 경우 다른 방향에서의 오목 존재여부를 확인하지 못할 수 있으므로 방향별 방문 배열을 나누어주었다.</p>\n<h3>맞왜틀 원인</h3>\n<ol>\n<li>6목 이상은 승리한 것이 아니라는 문제의 조건을 놓쳤다.</li>\n<li>대각선 방향을 우하향만 고려하여 풀이하였다.</li>\n<li>우에서 좌, 위에서 아래로 모든 좌표를 탐색하며 승리 여부를 판단하는 과정에서 두 가지 문제가 있었다.\n<ol>\n<li>'/' 모양을 검사하기 위해서 우상향 방향으로 탐색할 경우 탐색 순서에 의해서 6목도 5목으로 처리하는 경우가 있었다.</li>\n<li>그래서 우상향 대신 좌하향 방향으로 '/' 모양을 검사하였는데, 시작 좌표가 가장 왼쪽이 아니므로 따로 처리가 필요했다.</li>\n</ol>\n</li>\n</ol>","frontmatter":{"title":"2615번: 오목"}}},"pageContext":{"slug":"baekjoon/2615.js","slugNoExt":"baekjoon/2615","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}